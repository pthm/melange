package melange

import (
	"fmt"
	"io"
	"sort"
	"strings"
)

// GenerateConfig configures code generation.
// The generator produces Go code with type-safe constants for object types
// and relations defined in the FGA schema.
type GenerateConfig struct {
	// Package name for generated code. Default: "authz"
	Package string

	// RelationPrefixFilter is a prefix filter for relation names.
	// Only relations with this prefix will have constants generated.
	// If empty, all relations will be generated.
	//
	// Example: "can_" generates only permission relations, omitting roles.
	RelationPrefixFilter string

	// IDType specifies the type to use for object IDs.
	// Default: "string"
	// The type must implement fmt.Stringer or be safely convertible to string.
	//
	// Common values: "string", "int64", "uuid.UUID"
	// The generated code uses fmt.Sprint(id) for conversion.
	IDType string
}

// DefaultGenerateConfig returns sensible defaults.
// Package: "authz", no relation filter (all relations), string IDs.
func DefaultGenerateConfig() *GenerateConfig {
	return &GenerateConfig{
		Package:              "authz",
		RelationPrefixFilter: "", // Generate all relations by default
		IDType:               "string",
	}
}

// GenerateGo writes Go code for the types and relations from a parsed schema.
// Unlike some FGA implementations, this generates constants for ALL relations,
// not just those with "can_" prefix (unless filtered via config).
//
// The generated code includes:
//   - ObjectType constants (TypeUser, TypeRepository, etc.)
//   - Relation constants (RelCanRead, RelOwner, etc.)
//   - Constructor functions (User(id), Repository(id), etc.)
//   - Wildcard constructors (AnyUser(), AnyRepository(), etc.)
//
// The constructors return melange.Object values, enabling type-safe
// permission checks:
//
//	checker.Check(ctx, authz.User(123), authz.RelCanRead, authz.Repository(456))
//
// Wildcard constructors support public access patterns:
//
//	// Grant all users permission
//	INSERT INTO tuples (subject_type, subject_id, relation, object_type, object_id)
//	VALUES ('user', '*', 'can_read', 'repository', '456')
//
//	checker.Check(ctx, authz.AnyUser(), authz.RelCanRead, authz.Repository(456))
func GenerateGo(w io.Writer, types []TypeDefinition, cfg *GenerateConfig) error {
	// Validate schema before generating code
	if err := DetectCycles(types); err != nil {
		return err
	}

	if cfg == nil {
		cfg = DefaultGenerateConfig()
	}

	// Apply defaults for empty fields
	if cfg.IDType == "" {
		cfg.IDType = "string"
	}

	// Collect unique object types
	objectTypes := make([]string, 0, len(types))
	for _, t := range types {
		objectTypes = append(objectTypes, t.Name)
	}
	sort.Strings(objectTypes)

	// Collect ALL unique relations
	// Filter relations based on prefix filter
	relSet := make(map[string]bool)
	for _, t := range types {
		for _, r := range t.Relations {
			if cfg.RelationPrefixFilter == "" || strings.HasPrefix(r.Name, cfg.RelationPrefixFilter) {
				relSet[r.Name] = true
			}
		}
	}

	relations := make([]string, 0, len(relSet))
	for r := range relSet {
		relations = append(relations, r)
	}
	sort.Strings(relations)

	// Use a writer helper to accumulate errors
	ew := &errWriter{w: w}

	// Write header
	ew.writeln("// Code generated by melange. DO NOT EDIT.")

	ew.writeln("")
	ew.writef("package %s\n", cfg.Package)
	ew.writeln("")
	// Only import fmt if IDType is not string (need fmt.Sprint for conversion)
	if cfg.IDType == "string" {
		ew.writeln("import \"github.com/pthm/melange\"")
	} else {
		ew.writeln("import (")
		ew.writeln("\t\"fmt\"")
		ew.writeln("")
		ew.writeln("\t\"github.com/pthm/melange\"")
		ew.writeln(")")
	}
	ew.writeln("")

	// Write ObjectType constants
	ew.writeln("// ObjectType constants from schema.")
	ew.writeln("const (")
	for _, t := range objectTypes {
		constName := "Type" + pascalCase(t)
		ew.writef("\t%s melange.ObjectType = %q\n", constName, t)
	}
	ew.writeln(")")
	ew.writeln("")

	// Write Relation constants (ALL relations, not just can_*)

	ew.writeln("// Relations from schema.")
	ew.writeln("// ALL relations are generated, not just \"can_*\" permissions.")
	ew.writeln("const (")
	for _, r := range relations {
		// Convert relation name to constant name
		// e.g., "can_read" -> "RelCanRead", "owner" -> "RelOwner"
		constName := "Rel" + pascalCase(r)
		ew.writef("\t%s melange.Relation = %q\n", constName, r)
	}
	ew.writeln(")")

	ew.writeln("")

	// Write constructor functions
	ew.writeln("// Object constructors.")

	ew.writeln("")
	for _, t := range objectTypes {
		funcName := pascalCase(t)
		constName := "Type" + funcName
		ew.writef("// %s creates a %s object for relation checks.\n", funcName, t)
		// Use direct string assignment when IDType is string, otherwise use fmt.Sprint
		if cfg.IDType == "string" {
			ew.writef("func %s(id string) melange.Object { return melange.Object{Type: %s, ID: id} }\n\n", funcName, constName)
		} else {
			ew.writef("func %s(id %s) melange.Object { return melange.Object{Type: %s, ID: fmt.Sprint(id)} }\n\n", funcName, cfg.IDType, constName)
		}
	}

	// Write wildcard constructors

	ew.writeln("// Wildcard constructors for public access patterns.")
	ew.writeln("")
	for _, t := range objectTypes {
		funcName := "Any" + pascalCase(t)
		constName := "Type" + pascalCase(t)
		ew.writef("// %s returns a wildcard %s that matches type:* tuples.\n", funcName, t)
		ew.writef("func %s() melange.Object { return melange.Object{Type: %s, ID: \"*\"} }\n\n", funcName, constName)
	}

	return ew.err
}

// errWriter wraps an io.Writer and captures the first error.
// This simplifies error handling in sequential write operations.
type errWriter struct {
	w   io.Writer
	err error
}

func (ew *errWriter) writeln(s string) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintln(ew.w, s)
}

func (ew *errWriter) writef(format string, args ...any) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintf(ew.w, format, args...)
}

// pascalCase converts snake_case to PascalCase.
// Used for generating Go identifier names from FGA type and relation names.
// Examples: "can_read" → "CanRead", "user_group" → "UserGroup"
func pascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
