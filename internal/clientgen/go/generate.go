// Package gogen implements the Go client code generator for melange.
//
// This generator produces type-safe Go code from authorization schemas,
// including object type constants, relation constants, and constructor functions.
//
// Generated code uses the melange runtime (github.com/pthm/melange/melange)
// for type definitions.
package gogen

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/pthm/melange/internal/clientgen"
	"github.com/pthm/melange/pkg/schema"
)

func init() {
	clientgen.Register(&Generator{})
}

// Generator implements clientgen.Generator for Go.
type Generator struct{}

// Name returns "go" as the runtime identifier.
func (g *Generator) Name() string { return "go" }

// DefaultConfig returns default configuration for Go code generation.
func (g *Generator) DefaultConfig() *clientgen.Config {
	return &clientgen.Config{
		Package:        "authz",
		RelationFilter: "",
		IDType:         "string",
		Options:        make(map[string]any),
	}
}

// Generate produces Go client code from the given type definitions.
//
// Returns a single file map entry with key "schema_gen.go".
//
// Generated code includes:
//   - ObjectType constants (TypeUser, TypeRepository, etc.)
//   - Relation constants (RelCanRead, RelOwner, etc.)
//   - Constructor functions (User(id), Repository(id), etc.)
//   - Wildcard constructors (AnyUser(), AnyRepository(), etc.)
func (g *Generator) Generate(types []schema.TypeDefinition, cfg *clientgen.Config) (map[string][]byte, error) {
	// Validate schema before generating code
	if err := schema.DetectCycles(types); err != nil {
		return nil, err
	}

	if cfg == nil {
		cfg = g.DefaultConfig()
	}

	// Apply defaults for empty fields
	idType := cfg.IDType
	if idType == "" {
		idType = "string"
	}
	pkg := cfg.Package
	if pkg == "" {
		pkg = "authz"
	}

	// Collect unique object types
	objectTypes := make([]string, 0, len(types))
	for _, t := range types {
		objectTypes = append(objectTypes, t.Name)
	}
	sort.Strings(objectTypes)

	// Collect unique relations (with optional prefix filter)
	relSet := make(map[string]bool)
	for _, t := range types {
		for _, r := range t.Relations {
			if cfg.RelationFilter == "" || strings.HasPrefix(r.Name, cfg.RelationFilter) {
				relSet[r.Name] = true
			}
		}
	}

	relations := make([]string, 0, len(relSet))
	for r := range relSet {
		relations = append(relations, r)
	}
	sort.Strings(relations)

	// Generate code into buffer
	var buf bytes.Buffer
	ew := &errWriter{w: &buf}

	// Write header
	ew.writeln("// Code generated by melange. DO NOT EDIT.")
	ew.writeln("")
	ew.writef("package %s\n", pkg)
	ew.writeln("")

	// Only import fmt if IDType is not string (need fmt.Sprint for conversion)
	if idType == "string" {
		ew.writeln("import \"github.com/pthm/melange/melange\"")
	} else {
		ew.writeln("import (")
		ew.writeln("\t\"fmt\"")
		ew.writeln("")
		ew.writeln("\t\"github.com/pthm/melange/melange\"")
		ew.writeln(")")
	}
	ew.writeln("")

	// Write ObjectType constants
	ew.writeln("// ObjectType constants from schema.")
	ew.writeln("const (")
	for _, t := range objectTypes {
		constName := "Type" + pascalCase(t)
		ew.writef("\t%s melange.ObjectType = %q\n", constName, t)
	}
	ew.writeln(")")
	ew.writeln("")

	// Write Relation constants
	ew.writeln("// Relations from schema.")
	ew.writeln("// ALL relations are generated, not just \"can_*\" permissions.")
	ew.writeln("const (")
	for _, r := range relations {
		constName := "Rel" + pascalCase(r)
		ew.writef("\t%s melange.Relation = %q\n", constName, r)
	}
	ew.writeln(")")
	ew.writeln("")

	// Write constructor functions
	ew.writeln("// Object constructors.")
	ew.writeln("")
	for _, t := range objectTypes {
		funcName := pascalCase(t)
		constName := "Type" + funcName
		ew.writef("// %s creates a %s object for relation checks.\n", funcName, t)
		if idType == "string" {
			ew.writef("func %s(id string) melange.Object { return melange.Object{Type: %s, ID: id} }\n\n", funcName, constName)
		} else {
			ew.writef("func %s(id %s) melange.Object { return melange.Object{Type: %s, ID: fmt.Sprint(id)} }\n\n", funcName, idType, constName)
		}
	}

	// Write wildcard constructors
	ew.writeln("// Wildcard constructors for public access patterns.")
	ew.writeln("")
	for _, t := range objectTypes {
		funcName := "Any" + pascalCase(t)
		constName := "Type" + pascalCase(t)
		ew.writef("// %s returns a wildcard %s that matches type:* tuples.\n", funcName, t)
		ew.writef("func %s() melange.Object { return melange.Object{Type: %s, ID: \"*\"} }\n\n", funcName, constName)
	}

	if ew.err != nil {
		return nil, ew.err
	}

	return map[string][]byte{
		"schema_gen.go": buf.Bytes(),
	}, nil
}

// errWriter wraps a bytes.Buffer and captures the first error.
type errWriter struct {
	w   *bytes.Buffer
	err error
}

func (ew *errWriter) writeln(s string) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintln(ew.w, s)
}

func (ew *errWriter) writef(format string, args ...any) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintf(ew.w, format, args...)
}

// pascalCase converts snake_case to PascalCase.
func pascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if p != "" {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
