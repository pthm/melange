// Package typescript implements the TypeScript client code generator for melange.
//
// This generator produces type-safe TypeScript code from authorization schemas,
// including object type constants, relation constants, and factory functions.
//
// Generated code uses the @pthm/melange runtime package for type definitions.
package typescript

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/pthm/melange/internal/clientgen"
	"github.com/pthm/melange/pkg/schema"
)

func init() {
	clientgen.Register(&Generator{})
}

// Generator implements clientgen.Generator for TypeScript.
type Generator struct{}

// Name returns "typescript" as the runtime identifier.
func (g *Generator) Name() string { return "typescript" }

// DefaultConfig returns default configuration for TypeScript code generation.
func (g *Generator) DefaultConfig() *clientgen.Config {
	return &clientgen.Config{
		Package:        "", // Not used for TypeScript
		RelationFilter: "",
		IDType:         "string", // TypeScript always uses string
		Options:        make(map[string]any),
	}
}

// Generate produces TypeScript client code from the given type definitions.
//
// Returns a multi-file map with keys: "types.ts", "schema.ts", "index.ts".
//
// Generated code includes:
//   - types.ts: ObjectType/Relation constants and union types
//   - schema.ts: Factory functions and wildcard constructors
//   - index.ts: Re-exports for clean imports
func (g *Generator) Generate(types []schema.TypeDefinition, cfg *clientgen.Config) (map[string][]byte, error) {
	// Validate schema before generating code
	if err := schema.DetectCycles(types); err != nil {
		return nil, err
	}

	if cfg == nil {
		cfg = g.DefaultConfig()
	}

	// Collect unique object types
	objectTypes := make([]string, 0, len(types))
	for _, t := range types {
		objectTypes = append(objectTypes, t.Name)
	}
	sort.Strings(objectTypes)

	// Collect unique relations (with optional prefix filter)
	relSet := make(map[string]bool)
	for _, t := range types {
		for _, r := range t.Relations {
			if cfg.RelationFilter == "" || strings.HasPrefix(r.Name, cfg.RelationFilter) {
				relSet[r.Name] = true
			}
		}
	}

	relations := make([]string, 0, len(relSet))
	for r := range relSet {
		relations = append(relations, r)
	}
	sort.Strings(relations)

	// Generate each file
	files := make(map[string][]byte)

	typesContent, err := g.generateTypes(objectTypes, relations, cfg)
	if err != nil {
		return nil, err
	}
	files["types.ts"] = typesContent

	schemaContent, err := g.generateSchema(objectTypes, cfg)
	if err != nil {
		return nil, err
	}
	files["schema.ts"] = schemaContent

	indexContent, err := g.generateIndex(cfg)
	if err != nil {
		return nil, err
	}
	files["index.ts"] = indexContent

	return files, nil
}

// generateTypes creates the types.ts file with ObjectTypes and Relations constants.
func (g *Generator) generateTypes(objectTypes, relations []string, cfg *clientgen.Config) ([]byte, error) {
	var buf bytes.Buffer
	ew := &errWriter{w: &buf}

	// Write header
	ew.writeln("/**")
	ew.writeln(" * Generated by melange. DO NOT EDIT.")
	ew.writeln(" *")
	if cfg.Version != "" {
		ew.writef(" * melange version: %s\n", cfg.Version)
	}
	if cfg.SourcePath != "" {
		ew.writef(" * source: %s\n", cfg.SourcePath)
	}
	ew.writeln(" */")
	ew.writeln("")
	ew.writeln("import type { MelangeObject } from '@pthm/melange';")
	ew.writeln("")

	// Write ObjectTypes constant
	ew.writeln("/**")
	ew.writeln(" * ObjectTypes contains all object type constants from the schema.")
	ew.writeln(" */")
	ew.writeln("export const ObjectTypes = {")
	for _, t := range objectTypes {
		constName := pascalCase(t)
		ew.writef("  %s: %q,\n", constName, t)
	}
	ew.writeln("} as const;")
	ew.writeln("")

	// Write ObjectType union type
	ew.writeln("/**")
	ew.writeln(" * ObjectType is a union of all valid object types.")
	ew.writeln(" */")
	ew.writeln("export type ObjectType = (typeof ObjectTypes)[keyof typeof ObjectTypes];")
	ew.writeln("")

	// Write Relations constant
	ew.writeln("/**")
	ew.writeln(" * Relations contains all relation constants from the schema.")
	ew.writeln(" */")
	ew.writeln("export const Relations = {")
	for _, r := range relations {
		constName := pascalCase(r)
		ew.writef("  %s: %q,\n", constName, r)
	}
	ew.writeln("} as const;")
	ew.writeln("")

	// Write Relation union type
	ew.writeln("/**")
	ew.writeln(" * Relation is a union of all valid relations.")
	ew.writeln(" */")
	ew.writeln("export type Relation = (typeof Relations)[keyof typeof Relations];")
	ew.writeln("")

	if ew.err != nil {
		return nil, ew.err
	}

	return buf.Bytes(), nil
}

// generateSchema creates the schema.ts file with factory functions.
func (g *Generator) generateSchema(objectTypes []string, _ *clientgen.Config) ([]byte, error) {
	var buf bytes.Buffer
	ew := &errWriter{w: &buf}

	// Write header
	ew.writeln("/**")
	ew.writeln(" * Generated by melange. DO NOT EDIT.")
	ew.writeln(" */")
	ew.writeln("")
	ew.writeln("import type { MelangeObject } from '@pthm/melange';")
	ew.writeln("import { ObjectTypes } from './types.js';")
	ew.writeln("")

	// Write factory functions
	for _, t := range objectTypes {
		funcName := camelCase(t)
		constName := pascalCase(t)

		ew.writef("/**\n")
		ew.writef(" * %s creates a %s object for authorization checks.\n", funcName, t)
		ew.writef(" */\n")
		ew.writef("export function %s(id: string): MelangeObject {\n", funcName)
		ew.writef("  return { type: ObjectTypes.%s, id };\n", constName)
		ew.writef("}\n")
		ew.writeln("")

		// Write wildcard constructor
		wildcardName := "any" + constName
		ew.writef("/**\n")
		ew.writef(" * %s creates a wildcard %s object matching all instances.\n", wildcardName, t)
		ew.writef(" */\n")
		ew.writef("export function %s(): MelangeObject {\n", wildcardName)
		ew.writef("  return { type: ObjectTypes.%s, id: '*' };\n", constName)
		ew.writef("}\n")
		ew.writeln("")
	}

	if ew.err != nil {
		return nil, ew.err
	}

	return buf.Bytes(), nil
}

// generateIndex creates the index.ts file with re-exports.
func (g *Generator) generateIndex(_ *clientgen.Config) ([]byte, error) {
	var buf bytes.Buffer
	ew := &errWriter{w: &buf}

	// Write header
	ew.writeln("/**")
	ew.writeln(" * Generated by melange. DO NOT EDIT.")
	ew.writeln(" */")
	ew.writeln("")
	ew.writeln("export { ObjectTypes, Relations } from './types.js';")
	ew.writeln("export type { ObjectType, Relation } from './types.js';")
	ew.writeln("export * from './schema.js';")
	ew.writeln("")

	if ew.err != nil {
		return nil, ew.err
	}

	return buf.Bytes(), nil
}

// errWriter wraps a bytes.Buffer and captures the first error.
type errWriter struct {
	w   *bytes.Buffer
	err error
}

func (ew *errWriter) writeln(s string) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintln(ew.w, s)
}

func (ew *errWriter) writef(format string, args ...any) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintf(ew.w, format, args...)
}

// pascalCase converts snake_case to PascalCase.
// Examples: "user" -> "User", "pull_request" -> "PullRequest"
func pascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if p != "" {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}

// camelCase converts snake_case to camelCase.
// Examples: "user" -> "user", "pull_request" -> "pullRequest"
func camelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if i == 0 {
			// First part stays lowercase
			parts[i] = p
		} else if p != "" {
			// Subsequent parts are capitalized
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
